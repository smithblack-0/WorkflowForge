import torch
from torch import nn
from dataclasses import dataclass
from typing import Dict, List, Any, Optional, Tuple, Callable
from .resources import AbstractResource


@dataclass
class ResourceSpec:
    """
    A resource spec consists of the
    name of the resource and the arguments provided to it
    if any. It exactly says what this resource is
    expected to be called and what to call it with.
    """
    name: str
    arguments: Optional[Dict[str, Any]]

@dataclass
class Zone:
    """
    A zone consists of a collection of tokenized information,
    state machine information, and other features which
    can be used to drive the generation mechanism. It is,
    in essence, a declaration of what prompt to feed and what
    parameters to set when generating this zone.
    """
    tokens: torch.Tensor
    fsm_advance: int
    tags: torch.Tensor
    token_limit: int

class ZoneFactory:
    """
    The zone factory is a permanent entity capable of generating
    its associated zone by sampling its resources when called.
    """
    def __init__(self,
                 prompt: str,
                 resources: Dict[str, AbstractResource],
                 resource_specs: Dict[str, ResourceSpec],
                 tokenizer: Callable[[str], torch.Tensor],
                 tags: torch.Tensor,
                 fsm_advance_token: int,
                 gen_token_limit: int,
                 ):
        """

        :param prompt: The prompt to fill based on the callbacks
        :param resources: The resources usable for access
        :param resource_specs: The needed callbacks into the resources
        :param tokenizer: The tokenizer to tokenize with
        :param fsm_advance_token: The token to advance the fsm when generated or seen
        :param gen_token_limit: The maximum number of tokens to generate or provide before
               advancing to the next zone
        """
        self.prompt = prompt
        self.resources = resources
        self.resource_specs = resource_specs
        self.tokenizer = tokenizer
        self.fsm_advance_token = fsm_advance_token
        self.gen_token_limit = gen_token_limit
        self.tags = tags

    def resolve_resource_calls(self)->Dict[str, str]:
        """Resolves all resource calls into a formatting string for subsitution"""
        formatting_results = {}
        for placeholder in self.resource_specs.keys():
            name = self.resource_specs[placeholder].name
            arguments = self.resource_specs[placeholder].arguments
            if arguments is not None:
                formatting_results[placeholder] = self.resources[name](**arguments)
            else:
                formatting_results[placeholder] = self.resources[name]()
        return formatting_results

    def __call__(self)->Zone:
        """
        Sample from the resources, to return a completed zone
        :return: The zone
        """
        formatting_replacements = self.resolve_resource_calls()
        prompt = self.prompt.format(**formatting_replacements)
        tokens = self.tokenizer(prompt)
        return Zone(tokens, self.fsm_advance_token, self.tags, self.gen_token_limit)



class ZoneFactoryStub:
    """
    The zone factory stub is designed to contain much of
    the parsed information from the prompt file, and await
    further details to construct a full zone factory with.
    """
    def __init__(self,
                 resource_specs: Dict[str, ResourceSpec],
                 prompt: str,
                 tags: torch.Tensor,
                 state_advance_token: str,
                 gen_token_limit: int
                 ):
        """

        :param resource_specs: The required resource calls and their mappings onto placeholders
        :param prompt: The actual prompt for the zone
        :param tags: The tags, in tensor form, attached to the zone. Length N bool array, where N are the
                     number of tags
        :param state_advance_token:
                     A string token, which when generated by the model will advance it to the next
                     zone in the finite state backend.
        :param gen_token_limit: The maximum number of tokens this zone is allowed.
        """

        self.required_resources = set(spec.name for spec in resource_specs.values())
        self.resource_specs = resource_specs
        self.prompt = prompt
        self.tags = tags
        self.state_advance_token = state_advance_token
        self.gen_token_limit = gen_token_limit

    def __call__(self,
                 resources: Dict[str, AbstractResource],
                 tokenizer: Callable[[str], torch.Tensor]
                 ) -> ZoneFactory:
        """
        Factory method which binds the required additional zone information,
        checks for resource sanity, and performs a few additional conversions
        as well.
        :param resources: The collection of resources intended to resolve the dependencies
        :param tokenizer: The tokenizer to finish this process with
        :return: The prepared ZoneFactory
        """
        # Take care of advance token tokenization
        fsm_advance_token = tokenizer(self.state_advance_token)
        if fsm_advance_token.numel() != 1:
            raise ValueError(f"You may have forgotten to include '{self.state_advance_token}' as a special"
                             f" tokenizer case, as multiple tokens where returned when parsing it")
        fsm_advance_token = fsm_advance_token.item()

        # Check resources are sane.
        for placeholder, spec in self.resource_specs.items():
            if spec.name not in resources:
                raise ValueError(f"Resource '{spec.name}' (needed for placeholder '{placeholder}') is missing")

        # Get zone factory
        return ZoneFactory(self.prompt, resources, self.resource_specs,
                           tokenizer, self.tags, fsm_advance_token,
                           self.gen_token_limit)

class PromptSequenceFactory(nn.Module):
    """
    The Prompt Sequence Factory is designed to create
    and return a sequence of zones relevant to the project
    at hand whenever it is invoked. It is initialized
    with the parsing output and any additional dependencies.
    """
    def __init__(self,
                 zone_stubs: List[ZoneFactoryStub],
                 tokenizer: Callable[[str], torch.Tensor],
                 resources: Dict[str, AbstractResource],
                 ):
        """
        The initialization mechanism
        :param zone_stubs: Zone stubs, presumably from parsing
        :param tokenizer: The tokenizer to use
        :param resources: The resources to use
        """
        super().__init__()
        self.zone_factories = [zone_stub(resources, tokenizer) for zone_stub in zone_stubs]
    def forward(self)->List[Zone]:
        """
        Generates the list of zones
        :return: The zones that were made.
        """
        return [zone_factory() for zone_factory in self.zone_factories]
